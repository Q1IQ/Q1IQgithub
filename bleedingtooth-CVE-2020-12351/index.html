<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Linux 蓝牙bleedingtooth CVE-2020-12351学习记录</title><meta name="description" content="Being Honest With Yourself"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
水一篇分析文章，站在巨人的肩膀上。
漏洞分析CVE-2020-12351，该漏洞CVSS 评分为8.3 分，是一个基于堆的类型混淆(type confusion) 漏洞。在受害者蓝牙范围内的远程攻击者在指导目标设备的bd地址的情况下就可以利用该漏洞。攻击者可以通过发送恶意l2cap包的方式来触发该漏洞，引发DoS 或kernel 权限的任意代码执行。谷歌安全研究人员称该漏洞是一个零点击漏洞，也就是说利用的过程中无需任何的用户交互。

A heap-based 类型混淆 affecting Linux kernel 4.8 and higher was discovered in net/bluetooth/l2cap_core.c.

当 CID 不是 L2CAP_CID_SIGNALING, L2CAP.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Q1IQ's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Q1IQ's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Linux 蓝牙bleedingtooth CVE-2020-12351学习记录</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC"><span class="toc-text">POC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">真机调试环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/CVE"><i class="tag post-item-tag">CVE</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Linux 蓝牙bleedingtooth CVE-2020-12351学习记录</h1><time class="has-text-grey" datetime="2021-03-19T17:02:03.000Z">2021-03-20</time><article class="mt-2 post-content"><p><img src="/images/jonatan-pie-3l3RwQdHRHg-unsplash.jpg" alt="cover"></p>
<p>水一篇分析文章，站在巨人的肩膀上。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>CVE-2020-12351，该漏洞CVSS 评分为8.3 分，是一个基于堆的类型混淆(type confusion) 漏洞。在受害者蓝牙范围内的远程攻击者在指导目标设备的bd地址的情况下就可以利用该漏洞。攻击者可以通过发送恶意l2cap包的方式来触发该漏洞，引发DoS 或kernel 权限的任意代码执行。谷歌安全研究人员称该漏洞是一个零点击漏洞，也就是说利用的过程中无需任何的用户交互。</p>
<blockquote>
<p>A heap-based 类型混淆 affecting Linux kernel 4.8 and higher was discovered in net/bluetooth/l2cap_core.c.</p>
</blockquote>
<p>当 CID 不是 L2CAP_CID_SIGNALING, L2CAP_CID_CONN_LESS 或 L2CAP_CID_LE_SIGNALING时, l2cap_recv_frame 会调用 l2cap_data_channel() 。在l2cap_data_channel()中需要关注的是第8行的第27行的这两个分支。</p>
<pre><code>///net/bluetooth/l2cap_core.c
static void l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)
&#123;
    struct l2cap_chan *chan;
    chan = l2cap_get_chan_by_scid(conn, cid);
    if (!chan) &#123;
        if (cid == L2CAP_CID_A2MP) &#123;
            chan = a2mp_channel_create(conn, skb);  //here
            if (!chan) &#123;
                kfree_skb(skb);
                return;
            &#125;

            l2cap_chan_lock(chan);
        &#125; else &#123;
            BT_DBG(&quot;unknown cid 0x%4.4x&quot;, cid);
            /* Drop packet and return */
            kfree_skb(skb);
            return;
        &#125;
    &#125;
    ...
    switch (chan-&gt;mode) &#123;
    ...
    case L2CAP_MODE_ERTM:
    case L2CAP_MODE_STREAMING:
        l2cap_data_rcv(chan, skb);    //here
        goto done;
    ...
    &#125;

drop:
    kfree_skb(skb);

done:
    l2cap_chan_unlock(chan);
&#125;</code></pre>
<p>第27行：在 l2cap_data_channel 函数里如果 channel 的 mode 是 L2CAP_MODE_ERTM 或 L2CAP_MODE_STREAMING,  就会调用 l2cap_data_rcv()。</p>
<pre><code class="c">///net/bluetooth/l2cap_core.c
static int l2cap_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)
&#123;
    struct l2cap_ctrl *control = &amp;bt_cb(skb)-&gt;l2cap;
    u16 len;
    u8 event;

    __unpack_control(chan, skb);

    len = skb-&gt;len;

    /*
     * We can just drop the corrupted I-frame here.
     * Receiver will miss it and start proper recovery
     * procedures and ask for retransmission.
     */
    if (l2cap_check_fcs(chan, skb))  
        goto drop;

    if (!control-&gt;sframe &amp;&amp; control-&gt;sar == L2CAP_SAR_START)
        len -= L2CAP_SDULEN_SIZE;

    if (chan-&gt;fcs == L2CAP_FCS_CRC16)
        len -= L2CAP_FCS_SIZE;

    if (len &gt; chan-&gt;mps) &#123;
        l2cap_send_disconn_req(chan, ECONNRESET);
        goto drop;
    &#125;

    if ((chan-&gt;mode == L2CAP_MODE_ERTM ||
         chan-&gt;mode == L2CAP_MODE_STREAMING) &amp;&amp; sk_filter(chan-&gt;data, skb)) //here
        goto drop;
    ...
&#125;</code></pre>
<p>当packet的 checksum 被验证通过 , 继续调用 sk_filter()//sk_filter是对sk_filter_trim_cap的简单封装。</p>
<p>第8行： l2cap_data_channel 函数里 当使用的 CID 是 L2CAP_CID_A2MP 并且还没建立一个channel时 , a2mp_channel_create() 将被调用。</p>
<pre><code>///net/bluetooth/a2mp.c
static struct amp_mgr *amp_mgr_create(struct l2cap_conn *conn, bool locked)
&#123;
    struct amp_mgr *mgr;
    struct l2cap_chan *chan;

    mgr = kzalloc(sizeof(*mgr), GFP_KERNEL);
    if (!mgr)
        return NULL;

    BT_DBG(&quot;conn %p mgr %p&quot;, conn, mgr);

    mgr-&gt;l2cap_conn = conn;

    chan = a2mp_chan_open(conn, locked);  //here
    if (!chan) &#123;
        kfree(mgr);
        return NULL;
    &#125;

    mgr-&gt;a2mp_chan = chan;
    chan-&gt;data = mgr;
    ...
    return mgr;
&#125;</code></pre>
<p>a2mp_chan_open 创建了一个 channel 并且把 mode 初试化为 L2CAP_MODE_ERTM</p>
<pre><code>static struct l2cap_chan *a2mp_chan_open(struct l2cap_conn *conn, bool locked)
&#123;
    struct l2cap_chan *chan;
    int err;

    chan = l2cap_chan_create();
    if (!chan)
        return NULL;

    BT_DBG(&quot;chan %p&quot;, chan);

    chan-&gt;chan_type = L2CAP_CHAN_FIXED;
    chan-&gt;scid = L2CAP_CID_A2MP;
    chan-&gt;dcid = L2CAP_CID_A2MP;
    ...
    chan-&gt;mode = L2CAP_MODE_ERTM;
    ...
    return chan;
&#125;</code></pre>
<p>！！！问题在这里：</p>
<p>amp_mgr_create()里 chan-&gt;data 的类型是struct amp_mgr* </p>
<pre><code>static struct amp_mgr *amp_mgr_create(struct l2cap_conn *conn, bool locked)
&#123;
    struct amp_mgr *mgr;
     ...
     chan-&gt;data = mgr;
    ...
 &#125;</code></pre>
<p> 在l2cap_data_rcv()调用了sk_filter(chan-&gt;data, skb)，定义是这样的 sk_filter(struct sock *sk, struct sk_buff <em>skb); chan-&gt;data被转换成了struct sock\</em>类型，类型混淆在此产生。</p>
<pre><code> static int l2cap_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)
&#123;
    ...
    if ((chan-&gt;mode == L2CAP_MODE_ERTM ||
         chan-&gt;mode == L2CAP_MODE_STREAMING) &amp;&amp; sk_filter(chan-&gt;data, skb))
        goto drop;
    ...     
&#125;

int sk_filter(struct sock *sk, struct sk_buff *skb);
&#123;&#125;</code></pre>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p><a target="_blank" rel="noopener" href="https://github.com/google/security-research/security/advisories/GHSA-h637-c88j-47wq">https://github.com/google/security-research/security/advisories/GHSA-h637-c88j-47wq</a></p>
<p>mode：a2mp_chan_open 创建 channel的时候已把 mode 初试化为 L2CAP_MODE_ERTM。</p>
<p>cid：不应是 L2CAP_CID_SIGNALING, L2CAP_CID_CONN_LESS 或 L2CAP_CID_LE_SIGNALING，这里选择L2CAP_CID_A2MP。</p>
<pre><code>#define L2CAP_CID_SIGNALING    0x0001
#define L2CAP_CID_CONN_LESS    0x0002
#define L2CAP_CID_A2MP        0x0003
#define L2CAP_CID_ATT        0x0004
#define L2CAP_CID_LE_SIGNALING    0x0005
#define L2CAP_CID_SMP        0x0006
#define L2CAP_CID_SMP_BREDR    0x0007
#define L2CAP_CID_DYN_START    0x0040
#define L2CAP_CID_DYN_END    0xffff
#define L2CAP_CID_LE_DYN_END    0x007f</code></pre>
<p>crash了</p>
<p><img src="https://qiiq-1258887625.cos.ap-chengdu.myqcloud.com/20210310231756.png"></p>
<p><img src="https://qiiq-1258887625.cos.ap-chengdu.myqcloud.com/20210310231931.png"></p>
<h3 id="真机调试环境搭建"><a href="#真机调试环境搭建" class="headerlink" title="真机调试环境搭建"></a>真机调试环境搭建</h3><p><strong>Debugger配置</strong></p>
<p>1、下载符号文件和内核源码文件</p>
<p>为了更好地调试内核，gdb需要Debuggee的内核符号文件和源代码文件来实现源码级别的调试。之前发现了一个launchpad.net(<a target="_blank" rel="noopener" href="https://launchpad.net/ubuntu/+source/linux/5.4.0-42.46)%E7%9A%84%E7%AB%99%E7%82%B9%EF%BC%8C%E8%AF%A5%E7%AB%99%E7%82%B9%E6%8F%90%E4%BE%9B%E4%BA%86%E5%BD%93%E5%89%8D%E5%8F%91%E8%A1%8C%E7%89%88Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8%E7%AC%A6%E5%8F%B7%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E4%BE%9B%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8B%E8%BD%BD%E3%80%82">https://launchpad.net/ubuntu/+source/linux/5.4.0-42.46)的站点，该站点提供了当前发行版Linux系统的内核符号文件和源码文件供开发者下载。</a></p>
<p>找到Debuggee的ubuntu版本、 找带dbgsym、unsigned的、系统架构amd64</p>
<p><img src="https://qiiq-1258887625.cos.ap-chengdu.myqcloud.com/20211208014126.png"></p>
<p>2、安装符号文件</p>
<p>下载得到linux-image-unsigned-5.4.0-42-generic-dbgsym_5.4.0-42.46_amd64.ddeb文件，在Debugger中执行“dpkg -i”命令安装符号文件。 vmlinux-5.4.0-42-generic是Linux内核公共部分的可执行文件的符号版本</p>
<pre><code>file /usr/lib/debug/boot/vmlinux-5.11.0-38-generic
/usr/lib/debug/boot/vmlinux-5.11.0-38-generic: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=3943780ac8a93e50813a3906c205bba1515216d3, with debug_info, not stripped
file /usr/lib/debug/lib/modules/5.11.0-38-generic/kernel/drivers/net/ethernet/realtek/r8169.ko
/usr/lib/debug/lib/modules/5.11.0-38-generic/kernel/drivers/net/ethernet/realtek/r8169.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=ffa1e397cf00e133476ed9d9bcf168dac70a70c7, with debug_info, not stripped</code></pre>
<p><strong>Debugee配置</strong></p>
<p>1、开启kgdb</p>
<p>双机调试需要Debuggee开启Kgdb功能，当前Ubuntu发行版内核已经默认开启了 Kgdb支持，通过命令“cat /boot/config-$(uname -r)| grep -i GDB”查看可知当前内核支持Kgdb以及串口调试。</p>
<pre><code>q1iq@q1iq:~$ cat /boot/config-$(uname -r)| grep -i GDB
CONFIG_CFG80211_REQUIRE_SIGNED_REGDB=y
CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS=y
CONFIG_SERIAL_KGDB_NMI=y
CONFIG_GDB_SCRIPTS=y
CONFIG_HAVE_ARCH_KGDB=y
CONFIG_KGDB=y
CONFIG_KGDB_HONOUR_BLOCKLIST=y
CONFIG_KGDB_SERIAL_CONSOLE=y
# CONFIG_KGDB_TESTS is not set
CONFIG_KGDB_LOW_LEVEL_TRAP=y
CONFIG_KGDB_KDB=y</code></pre>
<p>如果内核不支持Kgdb，则可以通过下载、编译、安装对应版本的内核源码来打开Kgdb。以Linux5.4.0内核为例，需要设置的编译选项有:</p>
<pre><code>CONFIG_KGDB=y  //开启kgdb服务 
CONFIG_KGDB_SERIAL_CONSOLE=y  //kgdb默认连接到主板串口
CONFIG_DEBUG_INFO=y  //内核中加入调试符号</code></pre>
<p>2、配置grub文件</p>
<p>内核开启Kgdb功能后需要手动配置grub启动文件才能在开机的时候进入Kgdb调试选项，因为默认情况下Kgdb是不工作的，需要向内核传递相关启动参数才能启用。编辑/etc/grub.d/40_custom文件，添加如下menuentry。</p>
<p>kgdboc（串口调试）应加的选项</p>
<pre><code>kgdbwait kgdboc=ttyS0,115200 nokaslr
kgdbwait:进入该启动选项后等待远程主机连接Kgdb
kgdboc:“kgdb over console”的缩写，表示远程主机通过串口连接到Kgdb
ttyS0:在本地默认串口监听连接事件，通常这也是主板上唯一的串口
115200:本地串口的波特率 nokaslr:关闭内核地址随机化。kaslr选项会干扰内核的调试因此要关闭
除了串口还可以使用以太网连接Kgdb，除了传递启动参数还可以在运行时通过sysfs文件系统开启Kgdb 更多详细的Kgdb操作请参考“linux5.4/Documentation/dev-tools/kgdb.rst”。Linux的documentation是一个非常有用的东⻄</code></pre>
<p>kgbboe（网络调试）应该加这些选项(<a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/jwessel/kgdb/ch03s04.html">https://mirrors.edge.kernel.org/pub/linux/kernel/people/jwessel/kgdb/ch03s04.html</a>)</p>
<pre><code>kgdbwait kgdbcon kgdboe=@192.168.43.82/,@192.168.43.206/ nokaslr
kgdboe=[src-port]@&lt;src-ip&gt;/[dev],[tgt-port]@&lt;tgt-ip&gt;/[tgt-macaddr]

src-port默认6443
tgt-port默认6442

系统运行时修改kgdboe
echo &quot;@/,@10.0.2.2/&quot; &gt; /sys/module/kgdboe/paramters/kgdboe</code></pre>
<p>编辑完成后在控制台执行“sudo update-grub”命令更新启动项，重启Debuggee，可以在grub页面看到多出了“Ubuntu,KGDB with nokaslr”选项，这个选项是可以随便写的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sl9-2GZaJfqGwoHAHG8onQ">https://mp.weixin.qq.com/s/sl9-2GZaJfqGwoHAHG8onQ</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/awd-pwn-checker/" title="awd pwn checker编写记录"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: awd pwn checker编写记录</span></a><a class="button is-default" href="/awd-pwn/" title="awd pwn方向技巧小节"><span class="has-text-weight-semibold">Next: awd pwn方向技巧小节</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Q1IQ" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/Q1iqF"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Q1IQ"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Q1IQ 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>